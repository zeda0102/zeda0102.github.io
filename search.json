[{"title":"从zero开始学习command_block[置顶]","url":"/zeda0102.github.io/2022/04/14/%E4%BB%8Ezero%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0command_block/","content":"\n\n学习博客 by command_block\n","tags":["Study"]},{"title":"网络流复习笔记","url":"/zeda0102.github.io/2022/04/12/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%A4%8D%E4%B9%A0/","content":"本文复习网络流算法，许多内容未补充完整。\n\n\n\n费用流1. 运用EK+Dijkstra求解费用流　\n在原图G中给每个点定义势能 h[i]，并将其每一条边(u,v)的权值修改为 w[u][v]+h[u]-h[v]，得到的新图为G&#39;。\n\n首先，G&#39;中的最短路在G中也一定最短。\n    证明：\n        考虑任意一条最短路 (u,x,y,...,z,v)\n        在原图中的权值为w[u][x]+w[x][y]+...+w[z][v]\n        在新图中为 h[u]+w[u][x]-h[x]+h[x]+w[x][y]-h[y]+...+h[z]+w[z][v]-h[v]=w[u][x]+w[x][y]+...+w[z][y]+h[u]-h[v]\n    因此在起点与终点确定的时候，在G&#39;中的最短路在G中也一定最短\n\n考虑在费用流中构造势能 h[i]\n\n起初的费用流有流量(flow)的权值(cost)必定是正的，因此h[i]=0\n\n考虑增广后会加上部分反向边 (u,v), (u,v)必定在最短路上\n    dis[u]+w&#39;[u][v]=dis[v]\n    dis[u]+h[u]+w[u][v]-h[v]=dis[v]\n    (dis[u]+h[u])-(dis[v]+h[v])+w[u][v]=0\n    假使h[u]+=dis[u],h[v]+=dis[v]则w&#39;[u][v]必定不为负\n所以每次增广之后对于 h[i]+=dis[i],则保证正确性。\n\n　　\n2. zkw费用流zkw本人博客\n板子SPFA+SLF优化\n#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;climits&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;bool vis[200001];int dist[200001];//解释一下各数组的含义：vis两个用处：spfa里的访问标记，増广时候的访问标记，dist是每个点的距离标号int n,m,s,t,ans=0;//s是起点，t是终点，ans是费用答案int nedge=-1,p[200001],c[200001],cc[200001],nex[200001],head[200001];//这里是边表，解释一下各数组的含义：p[i]表示以某一点出发的编号为i的边对应点，c表示编号为i的边的流量，cc表示编号为i的边的费用，nex和head不说了吧。。。inline void addedge(int x,int y,int z,int zz)&#123;    p[++nedge]=y;c[nedge]=z;cc[nedge]=zz;nex[nedge]=head[x];head[x]=nedge;&#125;//建边（数组模拟边表倒挂）inline bool spfa(int s,int t)&#123;    memset(vis,0,sizeof vis);    for(int i=0;i&lt;=n;i++)dist[i]=1e9;dist[t]=0;vis[t]=1;//首先SPFA我们维护距离标号的时候要倒着跑，这样可以维护出到终点的最短路径    deque&lt;int&gt;q;q.push_back(t);//使用了SPFA的SLF优化（SLF可以自行百度或Google）    while(!q.empty())&#123;        int now=q.front();q.pop_front();        for(int k=head[now];k&gt;-1;k=nex[k])        if(c[k^1]&amp;&amp;dist[p[k]]&gt;dist[now]-cc[k])&#123;//首先c[k^1]是为什么呢，因为我们要保证正流，但是SPFA是倒着跑的，所以说我们要求c[k]的对应反向边是正的，这样保证走的方向是正确的            dist[p[k]]=dist[now]-cc[k];//因为已经是倒着的了，我们也可以很清楚明白地知道建边的时候反向边的边权是负的，所以减一下就对了（负负得正）            if(!vis[p[k]])&#123;                vis[p[k]]=1;                if(!q.empty()&amp;&amp;dist[p[k]]&lt;dist[q.front()])q.push_front(p[k]);else q.push_back(p[k]);//SLF优化            &#125;        &#125;        vis[now]=0;    &#125;    return dist[s]&lt;1e9;//判断起点终点是否连通&#125;inline int dfs(int x,int low)&#123;//这里就是进行増广了    if(x==t)&#123;vis[t]=1;return low;&#125;    int used=0,a;vis[x]=1;//这边是不是和dinic很像啊    for(int k=head[x];k&gt;-1;k=nex[k])    if(!vis[p[k]]&amp;&amp;c[k]&amp;&amp;dist[x]-cc[k]==dist[p[k]])&#123;//这个条件就表示这条边可以进行増广        a=dfs(p[k],min(c[k],low-used));        if(a)ans+=a*cc[k],c[k]-=a,c[k^1]+=a,used+=a;//累加答案，加流等操作都在这了        if(used==low)break;    &#125;    return used;&#125;inline int costflow()&#123;    int flow=0;    while(spfa(s,t))&#123;//判断起点终点是否连通，不连通说明满流，做完了退出        vis[t]=1;        while(vis[t])&#123;            memset(vis,0,sizeof vis);            flow+=dfs(s,1e9);//一直増广直到走不到为止（这样也可以省时间哦）        &#125;    &#125;    return flow;//这里返回的是最大流，费用的答案在ans里&#125;int main()&#123;    memset(nex,-1,sizeof nex);memset(head,-1,sizeof head);    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=1;i&lt;=m;i++)&#123;        int x,y,z,zz;scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;z,&amp;zz);        addedge(x,y,z,zz);addedge(y,x,0,-zz);    &#125;    printf(&quot;%d &quot;,costflow());printf(&quot;%d&quot;,ans);    return 0;&#125;\n\n\n模拟费用流（待补）上下界网络流（待补）"},{"title":"省选前的Train记录","url":"/zeda0102.github.io/2022/04/11/Train/","content":"每日做题的一些小结。\n\n\n4.12P5222 Game  \n网络流每次扩展一定会使其流量变大(&gt;&#x3D;1)， 若在使limit从1开始，便每次只会扩展的1流量。 \nDinic求最大流复杂度分为 层次网络(n次)-&gt;构建分层图(O(n))-&gt;增广（O(n*m))\nDinic算法复杂度分析及其证明\nzkw费用流复杂度为 层次网络(n次)-&gt;构建分层图(Dijkstra&#x2F;SPFA&#x2F;01SPFA - O(mlogn&#x2F;nk&#x2F;n))-&gt; 增广(O(n*m))\n整理了部分网络流ABC247-E\n口胡O(nlogn)二分算法　　枚举每个l,找到[l,r1]mx&gt;&#x3D;X,[l,r2]&gt;&#x3D;X+1,[l,r3]mn&lt;&#x3D;Y,[l,r4]mn&lt;&#x3D;Y-1,求线段[r1,r2-1]与线段[r3,r4-1]的交集长度累计\n题解是O(n),两种做法two-point与容斥\nABC247-F\n推导之后发现像Fib数列。\nABC247-G\n建图跑费用流。\nABC247-Ex瞎证明，瞎猜想c为颜色的数目k&lt;&#x3D;n-c与k&gt;n-c分类讨论，组合数的生成函数\n以上全是胡扯\n正解是多项式卷积优化dp (跳过)\n4.13bzoj2989\n切诺雪比夫距离与曼哈顿距离的转换-&gt;菱形区域与方形区域的转换\ncdq分治或树套树\n二进制分组\n大致学习了二进制分组的思想AGC045-A\n简单猜想 线性基,代码敲错了一次(v[i]写成了i)….\nAGC045-B\n自己不会，见题解后发现存在不必要计算的答案。\nZJOI2020传统艺能\n不会，去复习字符串算法了\nBorder理论小记 by cmd\nLyndon &amp; run by cmd\n没看\n4.15研究了cmd的莫比乌斯反演\nCF1043F Make It One\n4.16打了Atcoder比赛一场，表现分2200+\n4.17"},{"title":"二进制分组学习笔记","url":"/zeda0102.github.io/2022/04/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"简单学习，列出文章好的博客链接。\n\n\nMiracal\nDfkuaid\n应用于强制在线的题目，数据应当具有可合并性。\n在时间复杂度上会多个log\n"}]